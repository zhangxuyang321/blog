---
layout: pots
title: 数据结构与算法(14)_堆
date: 2019-01-14 14:55:06
tags: [算法,笔记]
categories: 算法
---
## 介绍
"堆"(Heap) 是一种特殊的树,它的应用场景非常多,最经典的莫过于堆排序.堆排序是一种原地的,时间复杂度为O(nlogn)的排序算法.

## 如何理解"堆"
什么样的树才是堆?需要满足两点要求:

* 堆是一个完全二叉树
* 堆中的每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值

对于每个节点的值都大于等于子树中每个节点的值的堆,我们叫做"大顶堆";对于每个节点的值都小于等于子树中每个节点的值的堆,我们叫做"小顶堆".

//TODO 图25

其中1,2是"大顶堆",3是"小顶堆",4不是堆.对于同一种数据,我们可以构建不同的堆形态.

## 如何实现一个堆
完全二叉树比较适合用数组来存储,如图一个用数组存储堆的例子:

//TODO 图26

从图中可以看到,数组中下标为i的节点的左子节点,就是下标为i * 2的节点,又子节点就是下标为i * 2 + 1的节点,父节点就是下标为i/2的节点.

### 往堆中插入一个元素
往堆中插入一个元素后,我们需要满足堆的两个要求.

如果我们把新插入的元素放到堆的最后,如图,已经不符合堆的特性了,于是我们需要进行调整,让其重新满足特性这个过程就叫<font color=red>堆化</font>.

//TODO 图27


堆化有两种方式,从下往上和从上往下.

#### 堆化_从下往上
堆化非常简单就是顺着节点所在的路径向上或者向下,对比,然后交换.

我们可以让新插入的节点与父节点比较大小.如果不满足子节点小于等于父节点的要求,我们就互换两个节点.一直重复这个过程,直到父子节点之间的关系满足.

```java
	public class Heap{
		private int[] a; //数组a,从下标1开始存储数据
		private int n;   //堆可以存储的最大数据
		private int count; //堆中已经存在的数据个数

		public Heap(int capacity){
			a = new int[capacity + 1];
			n = capacity;
			count = 0;
		}

		public void insert(int data){
			if(count >= n) return;
			++count;
			a[count] = data;
			int i = count;
			while(i/2 > 0 && a[i] > a[i/2]){
				swap(a, i, i/2); //用于交换下标为 i 和 i/2 的两个元素
				i = i/2;
			}
		}
	}
```

## 删除对顶元素
从堆的第二条定义中,任何节点的值都大于等于(或小于等于)子树节点的值,我们可以发现堆顶元素存储的就是最大值或最小值.

假设我们构造的是大顶堆,堆顶元素就是最大元素,当我们删除堆顶元素后,就需要把第二大元素放在堆顶,那第二大元素肯定会出现在左右子节点中.然后我们再迭代的删除第二大节点,以此类推直到叶子节点被删除.不过这种方法有点问题,就是最后堆化出来的堆并不满足完全二叉树的特性.

实际上,我们需要改变一下思路,来解决这个问题.我们把最后一个节点放在堆顶,然后利用同样的父子节点对比方法.对于不满足父子节点大小关系的,互换两个节点,并且重复执行这个过程,直到父子节点满足大小关系为止.这就是<font color=red>从上往下的堆化方法</font>.

//TODO 图28

```java
	public void removeMax(){
		if(count == 0) return;
		a[1] = a[count];
		--count;
		heapify(a, count, 1);
	}
	
	public void heapify(int[] a, int n, int i){
		while(true){
			int maxPos = i;
			if(i*2 <= n && a[i] < a[i*2]) maxPos = i * 2;
			if(i*2+1 <=n && a[maxPos] < a[i*2+1]) maxPos = i*2 +1;
			if(maxPos == i) break;
			swap(a, i, maxPos);
			i = maxPos;
		}
	}
```

我们知道,一个包含n个节点的安全二叉树,树的高度不会超过$$log_2n$$.堆化的过程是顺着节点所在的路径来比较交换的,所以堆化的时间复杂度跟树的高度成正比,也就是O(logn).插入数据和删除堆顶数据主要逻辑就是堆化,所以往堆中插入一个数据和删除堆顶数据的时间复杂度都是O(logn).

## 如何基于堆实现排序
我们可以把堆排序的过程大致拆分成两个步骤,<font color=red>建堆</font>和<font color=red>排序</font>.

### 建堆
我们首先将数组原地建成一个堆.建堆过程有两种思路.

第一种就是借助插入元素的思路.尽管数组中包含n个数据但是我们可以假设,起初堆中只包含一个数据,就是下标为1的数据,然后我们调用插入操作,将下标从2到n的数据依次插入到堆中.

第二种跟第一种截然相反.第一种建堆思路的处理过程是从前往后处理数组数据,并且每个数据插入堆中时,都是从下往上堆化.而第二种是从后往前处理数组,并且每个数据都是从上往下堆化.

//TODO 图29,30

```java
	private static void buildHeap(int[] a, int n){
		for(int i = n/2; i >= 1; --i;){
			heapify(a, n, i);
		}
	}

	private static void heapify(int[] a, int n, int i){
		while(true){
			int maxPos = i;
			if(i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
			if(i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
			if(maxPos == i) break;
			swap(a, i, maxPos);
			i = maxPos;
		}
	}
```

这段代码中,我们队下标从n/2开始到1的数据进行堆化,下标是 n/2+1 到 n 的节点是叶子节点我们不需要堆化,实际上对于完全二叉树来说,下标从 n/2+1 到 n 的节点都是叶子节点

建堆的时间复杂度是O(n);

### 排序
建堆完成后,数组中的数据已经是按照大顶堆的特性来组织的.数组的第一个元素就是堆顶,也是最大元素.我们把它跟最后一个数组交换,那最大元素就放到了下标为n的位置.

这个过程有点类似"删除堆顶的操作",当堆顶元素移除之后,我们把原先下标为n的元素放到堆顶,然后再通过堆化方法,将剩下n-1个数据重新构成堆.重复此过程,直到最后堆中只剩下下标为1的一个元素,排序就完成了.

//todo 图31

```java
	//n表示数据的个数,数组a 中的数据从下标1到n的位置
	public static void sort(int[] a, int n){
		buildHeap(a,n);
		int k = n;
		while(k > 1){
			swap(a,1,k);
			--k;
			heapify(a,k,i);
		}
	}
```

整个排序过程中,都只需要极个别的临时存储空间,所以堆排序是原地排序算法.堆排序包括建堆和排序两个操作,建堆过程的时间复杂度是O(n),排序过程的时间复杂的度是O(nlogn),所以堆排序整体的时间复杂度是O(nlogn).

堆排序不是稳定的排序算法,因为在排序的过程中,存在将堆的最后一个节点跟堆顶节点互换的操作.

## 实际开发中为什么快速排序比堆排序性能好

### 堆排序数据访问的方式没有快速排序友好.
对于快速排序来说,数据是顺序访问的而对于堆排序来说,数据是跳着访问的.

### 对于同样的数据,堆排序算法的交换次数要多余快速排序

	