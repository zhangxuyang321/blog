---
layout: pots
title: 数据结构与算法(5)_队列
date: 2018-12-12 15:19:25
tags: [算法,笔记]
categories: 算法
---
## 如何理解队列
先进先出,这就是典型的"队列".

最基本的操作: 入队, 放一个数据到对尾;出队,从队头取一个数据.队列跟栈一样也是一种受限的线性表数据结构

## 顺序队列和链式队列
用数组来实现的队列,叫顺序队列;用链表来实现的队列,叫链式队列.

### 顺序队列

```java
	//基于数组实现的队列
	public class ArrayQueue{
		//String数组items,大小为n
		private String[] items; 
		private int n;
		//head 代表对头下标,tail代表对尾下标
		private int head = 0;
		private int tail = 0;
	
		//初始化一个大小为n的数组
		public ArrayQueue(int n){
			items = new String[n];
			this.n = n;
		}

		//入队操作
		public boolean enqueue(String item){
			//taill == n  表示队列已满
			if(tail == n) return false;
			items[tail] = item;
			tail++;
			return true;
		}
		//出队操作
		public String dequeue(){
			//head == tail 表示队列为空
			if(head == tail) return null;
			String tmp = items[head];
			head++;
			return tmp;
		}
	}
```
//TODO
如图,上述代码中,随着不停地进行入队,出队操作,head和tail都会持续的向后移动,当tail等于n时,及时数组中还有空余空间(因为出队操作,head也会像n靠近),也无法添加数据.此时就需要<font color=red>数据搬移</font>.但是,每次进行出队操作都相当于删除数组下标为0的数据,要搬移整个队列中的数据,这样的出队操作时间复杂对就会从O(1) 变成 O(n).怎么优化呢?

实际上,我们在入队的时候,集中出发一次数据搬移操作就可以了.

```java
	...		

	public boolean enqueue(String item){
		if(tail == n){
			//如果head==0 && tail==n,此时数组中就没有空闲数据
			if(head == 0) return false;
			//否则进行数据搬移
			for(int i=head; i<tail; ++i){
				items[i-head] = item[i];
			}
			//数据搬移后,更新head和tail
			tail -= head;
			head = 0;
		}
		items[tail] = item;
		tail++;
		return true;
	}
	...
```

### 链式队列

```java
	public class QueueBasedOnLinkedList{
		Node head = null;
		Node tail = null;

		//入栈操作
		public void enqueue(String value){
			Node newNode = new Node(value,null);
			if(tail == null){
				head = newNode;
				tail = newNode;
			}else{
				newNode.next = tail;
				tail = tail.next;
			}
		}

		//出栈操作
		public String dequeue(){
			if(head == null) return null;
			String tmp = head.data;
			head = head.next;
			if(head == null){
				tail = null;	
			}
			return tmp;
		}

		public class Node(){
			public Node next;
			public String data;
			public Node(){
			}
			public Node(String data,Node next){
				this.data = data;
				this.next = next;
			}
		}
	}
```

## 循环队列

