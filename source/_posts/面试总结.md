---
title: 面试总结
date: 2018-03-06 10:29:01
tags: [java,android,笔记]
categories: 面试
---
基于鸿洋[公众号文章](http://mp.weixin.qq.com/s/p3l9wr4DX976Lr62-dYe8w)整理答案

# java 面试题
## java基础
###  java中==和equals和hashCode的区别

<!--more-->

1. "=="运算符用来比较两个变量的值是否相等.也就是说比较的是变量对应内
存中所存储的数值是否相同.要比较两个基本类型的数据或者两个引用变量
是否相等,只能使用"=="运算符
2. "equals"方法Obeject类中的方法,如果没有覆盖重写"equals"方法的话,"equals"方法会以"=="的方式比较l两个对象的引用是否相等.如果覆盖了"equals"方法即可自定义比较方式.例如String类中覆盖了"equals"方法,其比较的是字符串的序列.改写"equals"方法,必须要遵守通用约定: 
	* 自反性: 对于任意的引用值x，x.equals(x)一定为true。
	* 对称性：对于任意的引用值x 和 y，当x.equals(y)返回true时，y.equals(x)也一定返回true。 
	* 传递性：对于任意的引用值x、y和ｚ，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也一定返回true。
	*  一致性：对于任意的引用值x 和y，如果用于equals比较的对象信息没有被修改，多次调用x.equals(y)要么一致地返回true，要么一致地返回false。
	* 非空性：对于任意的非空引用值x，x.equals(null)一定返回false。
3. "hashCode"方法也是Obeject类中的方法,也可用来鉴定两个类是否相等,"hashCode"方法返回该对象的哈希码值,该值通常是一个由对象的内部地址转换的整数,它的实现主要是为了提高哈希表的性能.
<font color=#ff0000 >必须铭记: 每个重写了equals的类中,必须要重写hashCode方法.如果不这样的话就违反了Object.hashCode的通用约定，从而导致该类无法与所有基于散列值(hash)的集合类结合在一起正常运行</font>

4. hashCode()的返回值和equals()的关系如下:
	* equals相等的两个对象, hashCode值一定相等
	* equals不相等的两个对象,hashCode有可能相

### int、char、long各占多少字节数
* 1字节： byte , boolean
* 2字节： short , char
* 4字节： int , float
* 8字节： long , double
* 注：1字节(byte)=8位(bits)

### int与integer的区别
* integer是int的包装类型
* integer变量必须实例化后才能使用,而int变量不需要
* integer实际是对象的引用,当new一个integer时,实际上是生成一个指针指向此对象;而int则直接存储数值
* integer的默认值是null;int的默认值是0

#### 一些难点
* 两个通过new生成的integer变量不会相等
* integer和int比较时,只要两个变量值是相等的则结果为true

```java
Integer i = new Integer(100);
int a = 100;
i == a // true
// 因为Integer和int比较时,Java会自动拆包装为int,所以实际上是int与int的比较
```
* 非new生成的Integer和new生成的Integer的变量比较时结果为false

```java
Integer i = new Integer(100);
Integer j = 100;
i==j // false
//因为j生成的Integer指向的是Java常量池中的对象,而i生成的变量指向堆中的对象,地址值不同,所以不相等
```
* 对于两个非new的Integer对象进行比较,如果两个变量的值在-128~127之间结果为true,否则为false

```java
Integer i = 100;
Integer j = 100;
i==j //true
Integer m = 128;
Integer n =128;
m == n //false
```

### 谈谈对java多态的理解
> 多态字面意思即"多种状态",在面向对象语言中,接口多种不同的实现方式即为多态.引用Charlie Calverts对多态的描述——多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作.同一操作作用于不同的对象可以有不同的解释,产生不同的执行结果.在运行时,可以通过指向基类的指针,来调用派生类中的方法.

#### 多态三要素
Java中实现多态,要有集成,要有重写,父类引用指向子类对象
#### 多态的好处
* 可替换性: 多态可对已存在的代码具有可替换性.
* 可扩充性: 增加新的子类不影响已存在类的多态性,继承性以及其他特性的运行和操作
* 接口性: 多态类是超类通过方法签名,向子类提供一个共同的接口,由子类具体实现和完善
* 灵活性: 它在应用中体现了灵活多样的操作，提高了使用效率。
* 简化性: 多态简化对应用软件的代码编写和修改过程

#### 自己理解
	
我感觉因为有多态的存在,我们在代码编写中,才能将骨架抽取出来,
将相似的类进行归类.因为多态的就可以写出相同相貌.我们可以将子类向
上转型作为父类来做一些统一的操作,比如统一处理错误,统一处理相同的
操作,吐司,弹窗,loading加载等;也可以将父类向下转型到某一具体子类,
去做子类特定的操作.

### String,StringBuffer和StringBuilder的区别

* 在执行速度上StringBuilder > StringBuffer > String
* String 为字符串常量;StringBuilder与StringBuffer为字符串变量,即String对象一旦创建之后该对象是不可更改的,但后两者是可以更改的.
具体解释如下:

```java
	String str = "abc";
	System.out.println(str);
	str = str + "de";
	System.out.println(str);
```
运行这段代码,运行后先输出"abc",接着输出"abcde".看上去str改变了.实际运行过程为: 首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了.

而StringBuilder与StringBuffer是变量,对变量进行操作实际上就是对该对象进行修改,而不进行创建回收操作,所以在速度上要比String快很多

而StringBuilder与StringBuffer在方法是完全等价的,但是StringBuilders是线程不安全的;
StringBuffer的方法上带有synchronized关键字,是线程安全的

适用场景

* String适用于少量的字符串操作
* StringBuilder 适用于单线程下大量的字符串操作
* StringBuffer 适用于多线程下的大量字符串操作

### 什么是内部类,内部类的作用
> 内部类简单来说就是在一个类中还有一个类.可以分为成员内部类,局部内部类,静态内部类和匿名内部类.

#### 内部类分类
##### 成员内部类
* 作为外部类的一个成员存在,与外部类的成员,方法并列.

```java
	public class Outer {
		private String str1 = "我是外部类";
		private int i;
		//成员内部类
		class Inner{
			private String str2 = "我是内部类";
			public void test(){
				System.out.println(str1);
				System.out.println(str2);
			}
		}
	}

	Outer outer =  new Outer();
	Outer.Inner inner = outer.new Inner();
	inner.test();	
	//执行结果
	我是外部类
	我是内部类
```

* 特点: 
	* 成员内部类可以无条件访问外部类变量;即使是private的.
	* 但是外部类不能直接访问内部类,需要通过创建对象去访问;
	* 要想创建内部类,必须先创建外部类
	* 需要注意的是: <font color=#ff0000 >成员内部类不能含有static的变量,代码块和方法,因为成员内部类需要先创建外部类,才能创建自己</font>

##### 局部内部类
 * 定义在方法或者一个作用域中的内部类,他的访问权限仅限于他的作用域.

```java
public class Outer {
    private String str1 = "我是外部类";
    public void test(String text) {//jdk1.8不必用final修饰,但是1.7必须用final修饰
        class Inner {
            public void inTest() {
                System.out.println(str1);
                System.out.println(text);
            }
        }
        new Inner().inTest();
    }
}

Outer outer =  new Outer();
outer.test("我是测试数据");
//执行结果
我是外部类
我是测试数据

```
* 特点
	* 局部内部类类似局部变量,访问权限仅限于该作用域内
	* 需要注意的是: <font color=#ff0000 >局部内部类前不能加private,protected和public修饰,也不能用static修饰;内部类中也不能有static变量</font>

##### 静态内部类
