---
layout: posts
title: 数据结构与算法(1)_复杂度分析
date: 2018-12-03 15:21:50
tags: [算法,笔记]
categories: 算法
---

##  前言
今天在极客时间上开始了数据结构与算法的学习.这一块应该是我最大的薄弱点,希望能借此次学习与笔记,能把这一块短板补上.在此先立一个flag:每周至少一次发表一篇博客笔记.学好数据结构与算法,找到一份满意的工作.

## 复杂度分析的重要性
复杂度分析是整个算法学习的精髓,只要掌握了它,数据结构和算法的内容基本上就掌握了一半.

为什么这么说?

* 衡量编写的算法的执行效率,即时间、空间复杂度分析

* 基于不同设备的性能测试,无法统一执行效率的标准

* 数据量不够大,无法真实反映算法性能

所以,我们需要不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法.

## 大O复杂度方法

```java
	int cal(int n){
		int sum = 0;
		int i =1;
		for(i;i<=n;i++){
			sum = sum+i;
		}
		return sum;
	}
```
在以上代码中,假设每行代码的执行时间是一样的,即unitTime.第2,3行代码都是一个unitTime.第4,5行都是n个unitTime.执行时间即为(2n+2)*unitTime.即

<font size=5>所有代码执行时间T(n)与每行代码的执行时间成正比</font>

再看

```java
	int cal(int n){
		int sum = 0;
		int i = 1;	
		int j = 1;
		for(i;i<n;i++){
			j=1;
			for(j;j<n;j++){
				sum = sum+i*j;
			}
		}
	}
```
每行代码的执行时间还是unit_time,第2,3,4行分别是一个unitTime.第5,6行分别是n个unitTime.第7,8行分别是$$ n^2 $$个unitTime.所以执行时间          
(2$$ n^2 $$+2n+3)*unitTime

总结公式:T(n) = Of(n);

T(n)代表执行时间,n代表数据规模,f(n)代表表示每行代码执行的次数综合,因为这是一个公式,所以用f(n)表示.O表示代码的执行时间T(n)与f(n)表达式成正比.

### 渐进时间复杂度
根据上边公式,第一个例子T(n)=O(2n+n),第二个例子T(n)=O(2$$ n^2 $$ + 2n+3);这就是<font color=red>大O时间复杂度表示法.</font>大O时间复杂度实际上并不代表代码的具体执行时间,而是<font color=red>表示代码执行时间随数据规模增长的变化趋势</font>,所以也叫<font color=red>渐进时间复杂度</font>,简称<font color=red>时间复杂度.</font>

## 时间复杂度分析
如何分析一段代码的时间复杂度?

### 只关注循环次数最多的一段代码
大O这种复杂度表示方法表示的是一种变化趋势.通常忽略掉公式中的常量,低阶,系数,只需记住最大阶的量级就可以了.所以,<font color=red>我们在分析算法和代码的时间复杂度时,只关注循环次数最多的一段代码就可以了.</font>这段核心代码执行次数n的量级,就是整段代码的时间复杂度.

上面的第一个例子

```java
	int cal(int n){
		int sum = 0;
		int i =1;
		for(i;i<=n;i++){
			sum = sum+i;
		}
		return sum;
	}
```
其中第2,3行都是常量级,与n无关,所以对复杂度没有影响.第4,5行是重点,这两段代码执行了n次,所以总时间复杂度就是O(n);

### 加法法则: 总复杂度等于量级最大的那段代码的复杂度
一段代码的各个部分时间复杂度可能不同,此时我们取最大的时间复杂度作为本段代码的时间复杂度.

如果一段代码的某个部分,是常量的执行时间,不管是执行1万次,还是10万次,都是一个已知的数跟n无关,就可以忽略.因为时间复杂度表示的是一种变化趋势,虽然对代码执行时间有很大影响,但是对于变化趋势无关,所以我们就可以忽略.

### 乘法法则: 嵌套代码的复杂程度等于嵌套内外代码复杂度的乘积

```java
	int cal(int n){
		int sum = 0;
		int i =1;
		for(i;i<=n;i++){
			sum = sum+f(i);
		}
		return sum;
	}

	int f(int n){
		int sum = 0;
		int i =1;
		for(i;i<=n;i++){
			sum = sum+i;
		}
		return sum;
	}
```
单独看cal函数,假设f(i)只是一个普通操作,其复杂程度为T1(n)= O(n);
但,f(n)函数不是简单操作,其复杂程度为T2(n) = O(n);所以整个复杂程度就是T(n) = T1(n)*T2(n)=O(n * n)=O($$ n^2 $$)

## 几种常见的复杂度实例分析

### 常见复杂度量级
* O(1) 常量阶
* O(logn) 对数阶
* O(n) 线性阶
* O(nlogn) 线性对数阶
* O($$ n^2 $$) 平方阶,O($$ n^3 $$) 立方阶,O($$ n^k $$) k次方阶
* O($$ 2^n $$) 指数阶
* O(n!) 阶乘阶

与数据变化的趋势大概如下:

<img src="" />

以上常见复杂度量级可以分为多项式量阶和非多项式量阶,其中只有O($$ 2^n $$)和 O(n!)是非多项量阶.<font color=red>非多项式量阶在n越来越大时,其执行时间会急剧增加,是非常低效的算法</font>

#### O(1)
只要代码执行时间不随n的增大而增长,都是O(1).

#### O(logn)、O(nlogn) 最常见也最难分析

```java
	i = 1;
	while(i<=n){
		i = i * 2;
	}
```
当i从1开始取值,每循环一次就乘以2,当大于n时,循环结束.即:

$$ 2^0 $$,$$ 2^1 $$,$$ 2^2 $$,$$ 2^3 $$,...$$ 2^x $$ = n;

所以x即为代码的执行次数,x = $$ log_2n$$.所以时间复杂度为O($$ log_2n$$).<font color=red>在采用大O标记复杂度的时候可以忽略系数,因此不同对数,我们可以忽略对数的"底",统一表示为O(logn)</font>

那O(nlogn)就是一段代码时间复杂度为O(logn)的函数执行了n遍.例如归并排序,快速排序

#### O(m+n),O(m * n)
在以下情况下

```java
	int cal(int m,int n){
		int sum1 = 0;
		int i = 1;
		for(i;i<m;i++){
			sum1 = sum1+i;
		}
		int sum2 =0;
		int j = 1;
		for(j;j<n;j++){
			sum2 = sum2+j;
		}
		return sum1+sum2;
	}
```
此时,我们不知道m,n两个的数据规模,所以加法法则此时失效了.所以复杂度就是O(m+n);但是乘法法则继续有效O(m * n)

## 空间复杂度分析
> 也叫渐进空间复杂度,表示算法的存储空间与数据规模的增长关系

```java
	void print(int n){
		int i=0;
		int[] a = new int[n];
		for(i;i<n; ++i){
			a[i] = i * i;
		}
		
		for (i = n-1; i >= 0; --i) {
			System.out.println(a[i]);
		}
	}
```
第2行代码中,我们申请了一个空间存储常量i,它是常量阶跟数据n没有关系,可忽略.第3行申请了一个大小为n的int数组,除此之外并没有其他代码都没有占用太多空间,所以其空间复杂度为O(n);

