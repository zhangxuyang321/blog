---
layout: pots
title: 数据结构与算法(10)_散列表
date: 2018-12-25 14:52:13
tags: [算法,笔记]
categories: 算法
---
## 散列表
散列表英文名是"Hash Table",我们平时也叫"哈希表"或者"Hash 表".
<font color=red>散列表用的是数组支持按照下标随机访问的特性,所以散列表其实就是数组的一种扩展,由数组演化而来.</font>

<!-- more -->

散列表用的就是数组支持按下标随机访问的时候,时间复杂度为O(1)的特性.我们通过散列函数把元素的键值映射为下标,然后将数据存储在数组中对应下标的位置.当我们按照键值查询元素时,我们用同样的散列函数,将键值转话为数组下标,从对应的数组下标的位置取出数据.

## 散列函数
散列函数,顾名思义它是一个函数.我们可以把他定义成<font color=red>hash(key)</font>.其中key表示函数的键值,hash(key)的值表示经过散列函数计算得到的散列值.

### 散列函数设计的基本要求
* 散列函数计算得到的散列值是一个非负整数.
* 如果key1 == key2,那hash(key1) == hash(key2).
* 如果key1 != key2,那hash(key1) != hash(key2).

前两点没什么特别问题.至于第三点,在真实情况下要想找到<font color=red>一个不同的key对应的散列值都不一样的散列函数,几乎是不可能的</font>.即便是MD5,SHA,CRC等哈希算法,也无法避免这种<font color=red>散列冲突</font>.而且,因为数组的存储空间有限也会加大散列冲突的概率.

## 解决散列冲突
### 开放寻址法.
核心思想是,如果出现了散列冲突,我们就重新探测一个位置,将其插入.那如何探测新的位置呢?一个简单的方法是<font color=red>线性探测</font>.

当我们往散列表中插入数据时,如果某个数据经过散列函数后,存储位置已经被占用了,我们就从当前位置开始,依次往后查找,看是否有空闲位置,直到找到为止.

//TODO 图11

图中,黄色表示空闲,橙色表示占用.从图中看出,散列表大小为10,在元素X插入散列表之前,已经有6个元素插入到散列表中.X经过Hash算法之后,被散列到下标为7的位置,但是这个位置已经有数据了,所以就产生了冲突.于是顺序地往后一个一个找,看有没有空闲位置,遍历到尾部之后还是没有找到空闲位置,于是在从表头找,直到找到空闲位置2,于是将其插入到这个位置.

在散列表中查找元素的过程有点类似插入过程.我们通过散列函数求出查找元素的键值对应的散列值,然后比较数组的下标为散列值的元素和要查找的元素.如果相等,则返回.否则就往后依次查找.如果遍历到空闲位置,还没有找到,就说明要查找的元素,不在散列表中.

对于线性探测法解决冲突的散列表,删除操作有些特别.我们不能单独的把删除元素设置为空.因为在查找的时候,通过线性探测方法,找到一个空闲位置,我们就可以认定数据不在散列表中.但是,这个空闲位置是我们通过删除造成的,就会导致查询方法失效.

我们将删除的元素,特殊标记为deleted.当线性探测查找的时候,遇到标记为deleted的空间,并不是停下来,而是继续查找.

线性探测存在很大的问题.当散列表中插入的数据越来越多时,散列冲突发生的可能性就越来越大,空闲位置越来越少,线性探测越来越久.极端情况下,需要变量整个散列表,最坏时间复杂度是O(n).

开发寻址法除了线性探测外,还有另外两种比较经典的探测方法<font color=red>二次探测</font>和<font color=red>双重散列</font>.

不管哪种方法,当散列表中空闲位置不多时,散列冲突的概率都会提高.为了尽可能保证散列表的操作效率,一般情况下,我们会尽可能的保证散列表中有一定比例的空闲位置.我们用<font color=red>装载因子</font>来表示空位多少.公式为

散列表装载因子 = 填入表的元素个数 /  散列表长度.

<font color=red>装载因子越大,说明空闲位置越少,冲突越多,散列表的性能会下降</font>.

### 链表法
链表法是一种更加常用的散列冲突解决办法,相比开放寻址法,它要简单的多.如图,散列表中,每个"桶(bucket)" 或 "槽(slot)"会对应一条链表,所有散列值相同的元素我们都放到相同槽位对应的链表中.

//TODO, 图12

当插入的时候,我们只需要通过散列函数计算出对应的槽位,将其插入对应的链表即可,所以插入的时间复杂度O(1).当查找,删除一个元素时,我们同样通过散列函数计算出对应的槽,然后遍历链表查询或者删除.这两个操作的时间复杂度跟链表的长度k成正比,也就是O(k).对于散列表比均匀的散列表


