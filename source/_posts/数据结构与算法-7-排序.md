---
layout: pots
title: 数据结构与算法(7)_排序
date: 2018-12-17 10:06:53
tags: [算法,笔记]
categories: 算法
---

## 如何分析排序算法
### 排序算法的执行效率
#### 最好情况,最坏情况,平均情况时间复杂度
在分析排序算法的时间复杂度时,要分别给出,最坏,最好,平均情况下的时间复杂度.初次之外还要说出,最好,最坏时间复杂度对应要排序的原始数据是什么样.

这么区分的原因是:

* 有些排序算法会区分,为了好对比,所以我们最好都区分
* 对于要排序的数据,有的接近有序,有的完全无序.有序度不同的数据,对于排序的执行时间肯定是有影响的,我们要知道排序算法在不同数据下的性能表现

#### 时间复杂度的系数,常数,低阶
时间复杂度是反应数据规模n很大的时候的一个增长趋势,所以她表示的时候会忽略系数,常数,低阶.但是实际开发中,我们实际的排序数据可能是10个,100个,1000个.所以对同一阶时间复杂度排序算法性能比较的时候,我们就要把系数,常数,低阶也考虑进来.

#### 比较次数和交换(移动)
基于比较的排序算法的执行过程,会涉及两种操作,一种是元素比较大小,另一种事元素交换或移动.所以我们在分析排序算法的执行效率的时候,应该把比较次数和交换(移动)次数也考虑进去.

### 排序算法的内存消耗
算法的内存消耗可以通过空间复杂度来衡量,排序算法也不例外.针对排序算法的空间复杂度,我们还引入一个新的概念,<font color=red>原地排序</font>.原地排序算法就是特指空间复杂度是O(1)的排序算法.

### 排序算法的稳定性
针对排序算法,我们还有一个重要的度量指标,<font color=red>稳定性</font>.这个概念是说,如果排序的序列中存在值相等的元素,经过排序之后,相等元素之间原有的先后顺序不变.

比如我们有一组数据2,9,3,4,8,3.按照大小排序之后是2,3,3,4,8,9.这组数据里有两个3.经过某种排序算法之后,如果两个3的前后顺序没有改变,那么我们就把这种排序算法叫做<font color=red>稳定的排序算法</font>;如果前后顺序发生变化,那对应的排序算法就叫做不稳定排序算法.

## 冒泡排序
```java
	public void bubbleSort(int[] arr){
		int n = arr.length;
		if(n<=1) return;
		for(int i=0;i<n;i++){
			//提前退出冒泡排序的标志
			boolean flag = false;
			for(int j=0;j<n-i-1;j++){
				if(a[j] > a[j+1]){
					int tmp = a[j];
					a[j] = a[j+1];
					a[j+1] = tmp;
					flag = true; //表示有数据交换
				}
			}
			if(!flag) break;	//没有数据交换,提前退出
		}
	}
```

* 冒泡排序的过程只涉及相邻数据的交换操作,只需要常量级的临时空间,所以它的空间复杂度为O(1),是<font color=red>原地排序算法</font>
* 在冒泡排序中,只有交换才可以改变两个元素的先后顺序.为了保证冒泡排序算法的稳定性,当有两个元素大小相等的时候,我们不做交换,相同大小的数据在排序前后不会改变顺序,所以冒泡排序是<font color=red>稳定的排序算法</font>
* 冒泡排序的时间复杂度是,最好情况,要排序的数据已经有序了,我们只需要进行一次排序就够了,所以<font color=red>最好情况时间复杂度是O(n)</font>.而最坏的情况是,要排序的数据刚好是倒序排列的,我们需要进行n次冒泡操作,所以<font color=red>最坏时间复杂度是O($$n^2$$)</font>.

### 平均时间复杂度
对于包含n个数据的数组,这n个数据就有n!种排列方式.不同的排列方式,冒泡排序的执行时间肯定是不同的.如果用概率论方法定量分析平均时间复杂度,设计数学推理和计算会很复杂.我们通过<font color=red>有序度</font>和<font color=red>逆序度</font>,这两个概念来分析.


<font color=red>有序度</font>是数组中具有关系元素对的个数.有序元素对用数学表达式就是: a[i] <= a[j], 如果i < j;  例如图:

同理,对于一个倒序排列的数组,比如6,5,4,3,2,1,有序度是0;对于一个完全有序的数组,比如1,2,3,4,5,6有序度就是n*(n-1)/2,也就是15.我们把这种完全有序的数组的有序度叫做<font color=red>满有序度</font>.

<font color=red>逆序度</font>的定义正好跟有序度相反(默认从小到大为有序).即: a[i] > a[j], 其中i<j;

关于这三个概念,我们还可以得到一个公式: <font color=red>逆序度=满有序度-有序度</font>.我们排序的过程就是一种增加有序度,减少逆序度的过程,最后达到满有序度.

冒泡排序包含两个操作原子,比较和交换.每交换一次,有序度就加1.不管怎么改进算法,交换的次数总是确定的,即为逆序度,也就是n * (n-1)/2–初始有序度.对于包含n个数据的数组进行冒泡排序,初始状态的有序度是0,所以要进行n * (n-1)/2次交换.最好情况下有序度是n * (n-1)/2.就不需要进行交换.所以平均情况下,需要n * (n-1)/4次交换操作,比较操作肯定要比交换操作多,而复杂度的上限是O($$n^2$$),所以<font color=red>平均情况时间复杂度为O($$n^2$$)</font>

## 插入排序
首先我们将数组中的数据分为两个区间,<font color=red>已排序区间</font>和<font color=red>未排序区间</font>.初始已排序区间就是数组的第一个元素.插入算法的核心思想就是取未排序区间的元素,在已排序区间找到合适的位置插入,并保证已排序区间一直有序.重复这个过程,直到排序完成.

插入排序也包含两种操作,一种是元素比较,一种是元素移动.

```java
	public void insertionSort(int[] arr){
		int n = arr.length;
		if(n<=1) return;
		for(int i=1;i<n;i++){
			int value = arr[i];
			int j = i-1;
			for(;j>=0;--j){
				if(a[j] > value){
					a[j+1] = a[j]; //数据移动
				}else{
					break;
				}
			}
			a[j+1] = value; //插入数据
		}
	}
```

* 插入排序算法并不需要额外存储空间,所以它的空间复杂度为O(1),是<font color=red>原地排序算法</font>
* 对于值相同的元素我们可以选择将后面出现的元素,插入到前面元素的后面,这样就可以保持原有的前后顺序不变,所以插入排序是<font color=red>稳定的排序算法</font>
* 插入排序的时间复杂度. 如果排序的数据是有序的,我们并不需要搬移任何数据.如果我们从尾到头在有序的数据组里查找插入位置,每次只要比较一个数据就能确定位置,所以这种情况下<font color=red>最好时间复杂度是O(n)</font>.注意是<font color=red>从尾到头遍历已经有序的数据</font>.如果数组是倒序的,每次插入都相当于在数组的第一个位置插入新的数据.所以<font color=red>最坏情况时间复杂度为O($$n^2$$)</font>.数组中插入一个数据的平均时间复杂度是O(n),对于插入排序来说,每次插入操作都相当于在数组中插入一个数据,循环执行n次插入操作,所以<font color=red>平均时间复杂度为($$n^2$$)</font>.

## 选择排序
选择排序算法的实现思路类似插入排序,也分已排序区间和未排序区间.但是选择排序每次会从未排序区间找到最小的元素,将其放到已排序区间的末尾.

```java
	public static void selectionSort(int[] arr){
		int n = arr.length;
		if(n<=1) return;
		for(int i=0;i<n;i++){
			//查找最小值
			int minIndex = i;
			for(int j=i+1;j<n;j++){
				if(arr[j] < arr[minIndex]){
					minIndex = j;
				}
			}
			//交换
			int tmp = arr[i];
			arr[i] = arr[minIndex];
			arr[minIndex] = tmp;
		}
	}
```

* 选择排序的空间复杂度为O(1),也是原地排序算法.
* 选择排序是一种不稳定的排序算法
* 选择排序最好,最坏,平均时间复杂度都是O($$n^2$$).




